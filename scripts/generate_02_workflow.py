#!/usr/bin/env python3
"""
Generate .github/workflows/02-import-single.yml with a workflow_dispatch input
'repo_full' of type 'choice' populated from forks.json.

Usage:
  python3 scripts/generate_02_workflow.py forks.json > /dev/null
Then git add/. commit/push the generated workflow at .github/workflows/02-import-single.yml
"""
import json
import sys
from pathlib import Path

if len(sys.argv) < 2:
    print("Usage: generate_02_workflow.py forks.json", file=sys.stderr)
    sys.exit(2)

forks_path = Path(sys.argv[1])
if not forks_path.exists():
    print("File not found:", forks_path, file=sys.stderr)
    sys.exit(2)

data = json.load(forks_path.open())
options = []
for e in data:
    # use source (owner/repo) as option
    src = e.get("source") or f"{e.get('owner')}/{e.get('name')}"
    options.append(src)

# build YAML text for workflow
workflow_path = Path(".github/workflows/02-import-single.yml")
workflow_path.parent.mkdir(parents=True, exist_ok=True)

yaml_lines = []
yaml_lines.append("name: 02 - Import single fork (interactive select)")
yaml_lines.append("")
yaml_lines.append("on:")
yaml_lines.append("  workflow_dispatch:")
yaml_lines.append("    inputs:")
yaml_lines.append("      repo_full:")
yaml_lines.append("        description: 'Select a fork (owner/repo) to import from forks.json'")
yaml_lines.append("        required: true")
yaml_lines.append("        type: choice")
yaml_lines.append("        options:")
for o in options:
    yaml_lines.append(f"          - \"{o}\"")
yaml_lines.append("      run_mode:")
yaml_lines.append("        description: 'dry-run or real (real creates branch + PR)'")
yaml_lines.append("        required: true")
yaml_lines.append("        default: 'dry-run'")
yaml_lines.append("      migrate_path:")
yaml_lines.append("        description: 'Optional: override destination path inside monorepo'")
yaml_lines.append("        required: false")
yaml_lines.append("")
yaml_lines.append("permissions:")
yaml_lines.append("  contents: write")
yaml_lines.append("  pull-requests: write")
yaml_lines.append("")
yaml_lines.append("jobs:")
yaml_lines.append("  import_single:")
yaml_lines.append("    runs-on: ubuntu-latest")
yaml_lines.append("    steps:")
yaml_lines.append("      - name: Checkout repository")
yaml_lines.append("        uses: actions/checkout@v4")
yaml_lines.append("        with:")
yaml_lines.append("          fetch-depth: 1")
yaml_lines.append("")
yaml_lines.append("      - name: Install dependencies")
yaml_lines.append("        run: |")
yaml_lines.append("          sudo apt-get update -y")
yaml_lines.append("          sudo apt-get install -y jq rsync git curl")
yaml_lines.append("          python -m pip install --upgrade pip")
yaml_lines.append("          pip install PyYAML PyJWT cryptography requests")
yaml_lines.append("")
yaml_lines.append("      - name: Clean logs directory")
yaml_lines.append("        run: |")
yaml_lines.append("          mkdir -p logs")
yaml_lines.append("          rm -rf logs/* || true")
yaml_lines.append("")
yaml_lines.append("      - name: Generate GitHub App JWT")
yaml_lines.append("        id: gen_jwt")
yaml_lines.append("        env:")
yaml_lines.append("          APP_ID: ${{ secrets.APP_ID }}")
yaml_lines.append("          APP_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}")
yaml_lines.append("        run: |")
yaml_lines.append("          set -euo pipefail")
yaml_lines.append("          python3 scripts/app_jwt.py > jwt.txt")
yaml_lines.append("          JWT=$(cat jwt.txt)")
yaml_lines.append("          echo \"jwt=$JWT\" >> $GITHUB_OUTPUT")
yaml_lines.append("")
yaml_lines.append("      - name: Get GitHub App installation id for OurITRes")
yaml_lines.append("        id: get_installation")
yaml_lines.append("        env:")
yaml_lines.append("          JWT: ${{ steps.gen_jwt.outputs.jwt }}")
yaml_lines.append("        run: |")
yaml_lines.append("          set -euo pipefail")
yaml_lines.append("          curl -s -H \"Authorization: Bearer ${JWT}\" -H \"Accept: application/vnd.github+json\" \"https://api.github.com/app/installations\" > installations.json")
yaml_lines.append("          INST_ID=$(python3 scripts/get_installation_id.py ouritres < installations.json)")
yaml_lines.append("          if [ -z \"$INST_ID\" ]; then")
yaml_lines.append("            echo \"installation_id=\" >> $GITHUB_OUTPUT")
yaml_lines.append("            echo \"installation_response=$(jq -c . installations.json)\" >> $GITHUB_OUTPUT")
yaml_lines.append("            echo \"No installation for ouritres found\" >&2")
yaml_lines.append("            exit 1")
yaml_lines.append("          fi")
yaml_lines.append("          echo \"installation_id=$INST_ID\" >> $GITHUB_OUTPUT")
yaml_lines.append("")
yaml_lines.append("      - name: Create installation access token")
yaml_lines.append("        id: create_token")
yaml_lines.append("        env:")
yaml_lines.append("          JWT: ${{ steps.gen_jwt.outputs.jwt }}")
yaml_lines.append("          INSTALLATION_ID: ${{ steps.get_installation.outputs.installation_id }}")
yaml_lines.append("        run: |")
yaml_lines.append("          set -euo pipefail")
yaml_lines.append("          curl -s -X POST -H \"Authorization: Bearer ${JWT}\" -H \"Accept: application/vnd.github+json\" \"https://api.github.com/app/installations/${INSTALLATION_ID}/access_tokens\" > inst_token.json")
yaml_lines.append("          token=$(jq -r .token inst_token.json)")
yaml_lines.append("          if [ -z \"$token\" ] || [ \"$token\" = \"null\" ]; then")
yaml_lines.append("            echo \"Failed to create installation token: $(cat inst_token.json)\" >&2")
yaml_lines.append("            exit 1")
yaml_lines.append("          fi")
yaml_lines.append("          echo \"installation_token=$token\" >> $GITHUB_OUTPUT")
yaml_lines.append("")
yaml_lines.append("      - name: Run import for single repo (uses installation token)")
yaml_lines.append("        env:")
yaml_lines.append("          INSTALLATION_TOKEN: ${{ steps.create_token.outputs.installation_token }}")
yaml_lines.append("          REPO_FULL: ${{ github.event.inputs.repo_full }}")
yaml_lines.append("          RUN_MODE: ${{ github.event.inputs.run_mode }}")
yaml_lines.append("          MIGRATE_PATH: ${{ github.event.inputs.migrate_path }}")
yaml_lines.append("        run: |")
yaml_lines.append("          set -euo pipefail")
yaml_lines.append("          mkdir -p logs")
yaml_lines.append("          if [ -n \"${INSTALLATION_TOKEN:-}\" ]; then")
yaml_lines.append("            export FORKS_MANAGER_PAT=\"${INSTALLATION_TOKEN}\"")
yaml_lines.append("          fi")
yaml_lines.append("          chmod +x scripts/import_one_repo.sh")
yaml_lines.append("          ./scripts/import_one_repo.sh \"${REPO_FULL}\" \"${RUN_MODE}\" \"${MIGRATE_PATH:-}\" 2>&1 | tee \"logs/import-${REPO_FULL//\\//_}-${RUN_MODE}.log\"")
yaml_lines.append("")
yaml_lines.append("      - name: Upload logs (artifact)")
yaml_lines.append("        if: always()")
yaml_lines.append("        uses: actions/upload-artifact@v4")
yaml_lines.append("        with:")
yaml_lines.append("          name: import-single-logs")
yaml_lines.append("          path: logs/")
yaml_text = "\n".join(yaml_lines)

workflow_path.write_text(yaml_text)
print(f"Wrote workflow to {workflow_path} with {len(options)} options.")